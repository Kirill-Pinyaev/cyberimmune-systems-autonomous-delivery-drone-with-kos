/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/user/cyberimmune-systems-autonomous-delivery-drone-with-kos-contest/modules/DroneCAN/DSDL/com/tmotor/esc/1332.ParamGet.uavcan
 */

#ifndef COM_TMOTOR_ESC_PARAMGET_HPP_INCLUDED
#define COM_TMOTOR_ESC_PARAMGET_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

/******************************* Source text **********************************
#
# 1033.ParamGet.uavcan param get pack
#

OVERRIDE_SIGNATURE 0x462875A0ED874302

uint8 esc_index

uint32 esc_uuid

uint16 esc_id_req

uint16 esc_ov_threshold

uint16 esc_oc_threshold

uint16 esc_ot_threshold

uint16 esc_acc_threshold

uint16 esc_dacc_threshold

int16 esc_rotate_dir

uint8 esc_timing

uint16 esc_startup_times

uint32 esc_startup_duration

uint32 esc_product_date

uint32 esc_error_count

uint8 esc_signal_priority

uint16 esc_led_mode

uint8  esc_can_rate

uint16 esc_fdb_rate

uint8  esc_save_option

uint8[<=32] rsvd
******************************************************************************/

/********************* DSDL signature source definition ***********************
com.tmotor.esc.ParamGet
saturated uint8 esc_index
saturated uint32 esc_uuid
saturated uint16 esc_id_req
saturated uint16 esc_ov_threshold
saturated uint16 esc_oc_threshold
saturated uint16 esc_ot_threshold
saturated uint16 esc_acc_threshold
saturated uint16 esc_dacc_threshold
saturated int16 esc_rotate_dir
saturated uint8 esc_timing
saturated uint16 esc_startup_times
saturated uint32 esc_startup_duration
saturated uint32 esc_product_date
saturated uint32 esc_error_count
saturated uint8 esc_signal_priority
saturated uint16 esc_led_mode
saturated uint8 esc_can_rate
saturated uint16 esc_fdb_rate
saturated uint8 esc_save_option
saturated uint8[<=32] rsvd
******************************************************************************/

#undef esc_index
#undef esc_uuid
#undef esc_id_req
#undef esc_ov_threshold
#undef esc_oc_threshold
#undef esc_ot_threshold
#undef esc_acc_threshold
#undef esc_dacc_threshold
#undef esc_rotate_dir
#undef esc_timing
#undef esc_startup_times
#undef esc_startup_duration
#undef esc_product_date
#undef esc_error_count
#undef esc_signal_priority
#undef esc_led_mode
#undef esc_can_rate
#undef esc_fdb_rate
#undef esc_save_option
#undef rsvd

namespace com
{
namespace tmotor
{
namespace esc
{

template <int _tmpl>
struct UAVCAN_EXPORT ParamGet_
{
    typedef const ParamGet_<_tmpl>& ParameterType;
    typedef ParamGet_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
    };

    struct FieldTypes
    {
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_index;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_uuid;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_id_req;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_ov_threshold;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_oc_threshold;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_ot_threshold;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_acc_threshold;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_dacc_threshold;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessSigned, ::uavcan::CastModeSaturate > esc_rotate_dir;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_timing;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_startup_times;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_startup_duration;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_product_date;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_error_count;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_signal_priority;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_led_mode;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_can_rate;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_fdb_rate;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > esc_save_option;
        typedef ::uavcan::Array< ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate >, ::uavcan::ArrayModeDynamic, 32 > rsvd;
    };

    enum
    {
        MinBitLen
            = FieldTypes::esc_index::MinBitLen
            + FieldTypes::esc_uuid::MinBitLen
            + FieldTypes::esc_id_req::MinBitLen
            + FieldTypes::esc_ov_threshold::MinBitLen
            + FieldTypes::esc_oc_threshold::MinBitLen
            + FieldTypes::esc_ot_threshold::MinBitLen
            + FieldTypes::esc_acc_threshold::MinBitLen
            + FieldTypes::esc_dacc_threshold::MinBitLen
            + FieldTypes::esc_rotate_dir::MinBitLen
            + FieldTypes::esc_timing::MinBitLen
            + FieldTypes::esc_startup_times::MinBitLen
            + FieldTypes::esc_startup_duration::MinBitLen
            + FieldTypes::esc_product_date::MinBitLen
            + FieldTypes::esc_error_count::MinBitLen
            + FieldTypes::esc_signal_priority::MinBitLen
            + FieldTypes::esc_led_mode::MinBitLen
            + FieldTypes::esc_can_rate::MinBitLen
            + FieldTypes::esc_fdb_rate::MinBitLen
            + FieldTypes::esc_save_option::MinBitLen
            + FieldTypes::rsvd::MinBitLen
    };

    enum
    {
        MaxBitLen
            = FieldTypes::esc_index::MaxBitLen
            + FieldTypes::esc_uuid::MaxBitLen
            + FieldTypes::esc_id_req::MaxBitLen
            + FieldTypes::esc_ov_threshold::MaxBitLen
            + FieldTypes::esc_oc_threshold::MaxBitLen
            + FieldTypes::esc_ot_threshold::MaxBitLen
            + FieldTypes::esc_acc_threshold::MaxBitLen
            + FieldTypes::esc_dacc_threshold::MaxBitLen
            + FieldTypes::esc_rotate_dir::MaxBitLen
            + FieldTypes::esc_timing::MaxBitLen
            + FieldTypes::esc_startup_times::MaxBitLen
            + FieldTypes::esc_startup_duration::MaxBitLen
            + FieldTypes::esc_product_date::MaxBitLen
            + FieldTypes::esc_error_count::MaxBitLen
            + FieldTypes::esc_signal_priority::MaxBitLen
            + FieldTypes::esc_led_mode::MaxBitLen
            + FieldTypes::esc_can_rate::MaxBitLen
            + FieldTypes::esc_fdb_rate::MaxBitLen
            + FieldTypes::esc_save_option::MaxBitLen
            + FieldTypes::rsvd::MaxBitLen
    };

    // Constants

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::esc_index >::Type esc_index;
    typename ::uavcan::StorageType< typename FieldTypes::esc_uuid >::Type esc_uuid;
    typename ::uavcan::StorageType< typename FieldTypes::esc_id_req >::Type esc_id_req;
    typename ::uavcan::StorageType< typename FieldTypes::esc_ov_threshold >::Type esc_ov_threshold;
    typename ::uavcan::StorageType< typename FieldTypes::esc_oc_threshold >::Type esc_oc_threshold;
    typename ::uavcan::StorageType< typename FieldTypes::esc_ot_threshold >::Type esc_ot_threshold;
    typename ::uavcan::StorageType< typename FieldTypes::esc_acc_threshold >::Type esc_acc_threshold;
    typename ::uavcan::StorageType< typename FieldTypes::esc_dacc_threshold >::Type esc_dacc_threshold;
    typename ::uavcan::StorageType< typename FieldTypes::esc_rotate_dir >::Type esc_rotate_dir;
    typename ::uavcan::StorageType< typename FieldTypes::esc_timing >::Type esc_timing;
    typename ::uavcan::StorageType< typename FieldTypes::esc_startup_times >::Type esc_startup_times;
    typename ::uavcan::StorageType< typename FieldTypes::esc_startup_duration >::Type esc_startup_duration;
    typename ::uavcan::StorageType< typename FieldTypes::esc_product_date >::Type esc_product_date;
    typename ::uavcan::StorageType< typename FieldTypes::esc_error_count >::Type esc_error_count;
    typename ::uavcan::StorageType< typename FieldTypes::esc_signal_priority >::Type esc_signal_priority;
    typename ::uavcan::StorageType< typename FieldTypes::esc_led_mode >::Type esc_led_mode;
    typename ::uavcan::StorageType< typename FieldTypes::esc_can_rate >::Type esc_can_rate;
    typename ::uavcan::StorageType< typename FieldTypes::esc_fdb_rate >::Type esc_fdb_rate;
    typename ::uavcan::StorageType< typename FieldTypes::esc_save_option >::Type esc_save_option;
    typename ::uavcan::StorageType< typename FieldTypes::rsvd >::Type rsvd;

    ParamGet_()
        : esc_index()
        , esc_uuid()
        , esc_id_req()
        , esc_ov_threshold()
        , esc_oc_threshold()
        , esc_ot_threshold()
        , esc_acc_threshold()
        , esc_dacc_threshold()
        , esc_rotate_dir()
        , esc_timing()
        , esc_startup_times()
        , esc_startup_duration()
        , esc_product_date()
        , esc_error_count()
        , esc_signal_priority()
        , esc_led_mode()
        , esc_can_rate()
        , esc_fdb_rate()
        , esc_save_option()
        , rsvd()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<590 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    enum { DefaultDataTypeID = 1332 };

    static const char* getDataTypeFullName()
    {
        return "com.tmotor.esc.ParamGet";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool ParamGet_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        esc_index == rhs.esc_index &&
        esc_uuid == rhs.esc_uuid &&
        esc_id_req == rhs.esc_id_req &&
        esc_ov_threshold == rhs.esc_ov_threshold &&
        esc_oc_threshold == rhs.esc_oc_threshold &&
        esc_ot_threshold == rhs.esc_ot_threshold &&
        esc_acc_threshold == rhs.esc_acc_threshold &&
        esc_dacc_threshold == rhs.esc_dacc_threshold &&
        esc_rotate_dir == rhs.esc_rotate_dir &&
        esc_timing == rhs.esc_timing &&
        esc_startup_times == rhs.esc_startup_times &&
        esc_startup_duration == rhs.esc_startup_duration &&
        esc_product_date == rhs.esc_product_date &&
        esc_error_count == rhs.esc_error_count &&
        esc_signal_priority == rhs.esc_signal_priority &&
        esc_led_mode == rhs.esc_led_mode &&
        esc_can_rate == rhs.esc_can_rate &&
        esc_fdb_rate == rhs.esc_fdb_rate &&
        esc_save_option == rhs.esc_save_option &&
        rsvd == rhs.rsvd;
}

template <int _tmpl>
bool ParamGet_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(esc_index, rhs.esc_index) &&
        ::uavcan::areClose(esc_uuid, rhs.esc_uuid) &&
        ::uavcan::areClose(esc_id_req, rhs.esc_id_req) &&
        ::uavcan::areClose(esc_ov_threshold, rhs.esc_ov_threshold) &&
        ::uavcan::areClose(esc_oc_threshold, rhs.esc_oc_threshold) &&
        ::uavcan::areClose(esc_ot_threshold, rhs.esc_ot_threshold) &&
        ::uavcan::areClose(esc_acc_threshold, rhs.esc_acc_threshold) &&
        ::uavcan::areClose(esc_dacc_threshold, rhs.esc_dacc_threshold) &&
        ::uavcan::areClose(esc_rotate_dir, rhs.esc_rotate_dir) &&
        ::uavcan::areClose(esc_timing, rhs.esc_timing) &&
        ::uavcan::areClose(esc_startup_times, rhs.esc_startup_times) &&
        ::uavcan::areClose(esc_startup_duration, rhs.esc_startup_duration) &&
        ::uavcan::areClose(esc_product_date, rhs.esc_product_date) &&
        ::uavcan::areClose(esc_error_count, rhs.esc_error_count) &&
        ::uavcan::areClose(esc_signal_priority, rhs.esc_signal_priority) &&
        ::uavcan::areClose(esc_led_mode, rhs.esc_led_mode) &&
        ::uavcan::areClose(esc_can_rate, rhs.esc_can_rate) &&
        ::uavcan::areClose(esc_fdb_rate, rhs.esc_fdb_rate) &&
        ::uavcan::areClose(esc_save_option, rhs.esc_save_option) &&
        ::uavcan::areClose(rsvd, rhs.rsvd);
}

template <int _tmpl>
int ParamGet_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::esc_index::encode(self.esc_index, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_uuid::encode(self.esc_uuid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_id_req::encode(self.esc_id_req, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_ov_threshold::encode(self.esc_ov_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_oc_threshold::encode(self.esc_oc_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_ot_threshold::encode(self.esc_ot_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_acc_threshold::encode(self.esc_acc_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_dacc_threshold::encode(self.esc_dacc_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_rotate_dir::encode(self.esc_rotate_dir, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_timing::encode(self.esc_timing, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_startup_times::encode(self.esc_startup_times, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_startup_duration::encode(self.esc_startup_duration, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_product_date::encode(self.esc_product_date, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_error_count::encode(self.esc_error_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_signal_priority::encode(self.esc_signal_priority, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_led_mode::encode(self.esc_led_mode, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_can_rate::encode(self.esc_can_rate, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_fdb_rate::encode(self.esc_fdb_rate, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_save_option::encode(self.esc_save_option, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::rsvd::encode(self.rsvd, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int ParamGet_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::esc_index::decode(self.esc_index, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_uuid::decode(self.esc_uuid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_id_req::decode(self.esc_id_req, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_ov_threshold::decode(self.esc_ov_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_oc_threshold::decode(self.esc_oc_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_ot_threshold::decode(self.esc_ot_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_acc_threshold::decode(self.esc_acc_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_dacc_threshold::decode(self.esc_dacc_threshold, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_rotate_dir::decode(self.esc_rotate_dir, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_timing::decode(self.esc_timing, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_startup_times::decode(self.esc_startup_times, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_startup_duration::decode(self.esc_startup_duration, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_product_date::decode(self.esc_product_date, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_error_count::decode(self.esc_error_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_signal_priority::decode(self.esc_signal_priority, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_led_mode::decode(self.esc_led_mode, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_can_rate::decode(self.esc_can_rate, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_fdb_rate::decode(self.esc_fdb_rate, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::esc_save_option::decode(self.esc_save_option, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::rsvd::decode(self.rsvd, codec,  tao_mode);
    return res;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature ParamGet_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0x462875A0ED874302ULL);

    FieldTypes::esc_index::extendDataTypeSignature(signature);
    FieldTypes::esc_uuid::extendDataTypeSignature(signature);
    FieldTypes::esc_id_req::extendDataTypeSignature(signature);
    FieldTypes::esc_ov_threshold::extendDataTypeSignature(signature);
    FieldTypes::esc_oc_threshold::extendDataTypeSignature(signature);
    FieldTypes::esc_ot_threshold::extendDataTypeSignature(signature);
    FieldTypes::esc_acc_threshold::extendDataTypeSignature(signature);
    FieldTypes::esc_dacc_threshold::extendDataTypeSignature(signature);
    FieldTypes::esc_rotate_dir::extendDataTypeSignature(signature);
    FieldTypes::esc_timing::extendDataTypeSignature(signature);
    FieldTypes::esc_startup_times::extendDataTypeSignature(signature);
    FieldTypes::esc_startup_duration::extendDataTypeSignature(signature);
    FieldTypes::esc_product_date::extendDataTypeSignature(signature);
    FieldTypes::esc_error_count::extendDataTypeSignature(signature);
    FieldTypes::esc_signal_priority::extendDataTypeSignature(signature);
    FieldTypes::esc_led_mode::extendDataTypeSignature(signature);
    FieldTypes::esc_can_rate::extendDataTypeSignature(signature);
    FieldTypes::esc_fdb_rate::extendDataTypeSignature(signature);
    FieldTypes::esc_save_option::extendDataTypeSignature(signature);
    FieldTypes::rsvd::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

/*
 * Final typedef
 */
typedef ParamGet_<0> ParamGet;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::com::tmotor::esc::ParamGet > _uavcan_gdtr_registrator_ParamGet;

}

} // Namespace esc
} // Namespace tmotor
} // Namespace com

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::com::tmotor::esc::ParamGet >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::com::tmotor::esc::ParamGet::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::com::tmotor::esc::ParamGet >::stream(Stream& s, ::com::tmotor::esc::ParamGet::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "esc_index: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_index >::stream(s, obj.esc_index, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_uuid: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_uuid >::stream(s, obj.esc_uuid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_id_req: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_id_req >::stream(s, obj.esc_id_req, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_ov_threshold: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_ov_threshold >::stream(s, obj.esc_ov_threshold, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_oc_threshold: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_oc_threshold >::stream(s, obj.esc_oc_threshold, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_ot_threshold: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_ot_threshold >::stream(s, obj.esc_ot_threshold, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_acc_threshold: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_acc_threshold >::stream(s, obj.esc_acc_threshold, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_dacc_threshold: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_dacc_threshold >::stream(s, obj.esc_dacc_threshold, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_rotate_dir: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_rotate_dir >::stream(s, obj.esc_rotate_dir, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_timing: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_timing >::stream(s, obj.esc_timing, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_startup_times: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_startup_times >::stream(s, obj.esc_startup_times, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_startup_duration: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_startup_duration >::stream(s, obj.esc_startup_duration, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_product_date: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_product_date >::stream(s, obj.esc_product_date, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_error_count: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_error_count >::stream(s, obj.esc_error_count, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_signal_priority: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_signal_priority >::stream(s, obj.esc_signal_priority, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_led_mode: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_led_mode >::stream(s, obj.esc_led_mode, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_can_rate: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_can_rate >::stream(s, obj.esc_can_rate, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_fdb_rate: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_fdb_rate >::stream(s, obj.esc_fdb_rate, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "esc_save_option: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::esc_save_option >::stream(s, obj.esc_save_option, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "rsvd: ";
    YamlStreamer< ::com::tmotor::esc::ParamGet::FieldTypes::rsvd >::stream(s, obj.rsvd, level + 1);
}

}

namespace com
{
namespace tmotor
{
namespace esc
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::com::tmotor::esc::ParamGet::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::com::tmotor::esc::ParamGet >::stream(s, obj, 0);
    return s;
}

} // Namespace esc
} // Namespace tmotor
} // Namespace com

#endif // COM_TMOTOR_ESC_PARAMGET_HPP_INCLUDED