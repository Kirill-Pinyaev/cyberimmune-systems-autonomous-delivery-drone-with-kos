/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/user/cyberimmune-systems-autonomous-delivery-drone-with-kos-contest/modules/DroneCAN/DSDL/com/xacti/20305.GnssStatus.uavcan
 */

#ifndef COM_XACTI_GNSSSTATUS_HPP_INCLUDED
#define COM_XACTI_GNSSSTATUS_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

/******************************* Source text **********************************
#
# Xacti GNSS status
#

# signature from original file location
OVERRIDE_SIGNATURE 0x3413AC5D3E1DCBE3

#
# GPS status
# 0: Invalid.  all fields except order and remain_buffer should be zero
# 1: No CAM_SYNC requests. all other fields should be zero
# 2: Valid
#
uint8 gps_status

#
# order
# request sequence number in range from 0 to 21.  incremented each time
# will be 0 in response to a GnssStatusReq with 'requirement' field of 0 (clear buffer)
#
uint8 order

#
# remain_buffer
# number of buffers remaining in range from 0 to 21.  0 is empty
#
uint8 remain_buffer

#
# UTCD year, month, day, hour minute and second
#
uint16 utc_year     # 2023 ~
uint8 utc_month     # 1 ~ 12
uint8 utc_day       # 1 ~ 31
uint8 utc_hour      # 0 ~ 23
uint8 utc_minute    # 0 ~ 59
float32 utc_seconds # 0 ~ below 60

#
# latitude, longitude, altitude (in meters, AMSL)
#
float64 latitude    # degrees -90 ~ +90
float64 longitude   # degrees -180 ~ +180
float32 altitude    # meters above sea level, AMSL
******************************************************************************/

/********************* DSDL signature source definition ***********************
com.xacti.GnssStatus
saturated uint8 gps_status
saturated uint8 order
saturated uint8 remain_buffer
saturated uint16 utc_year
saturated uint8 utc_month
saturated uint8 utc_day
saturated uint8 utc_hour
saturated uint8 utc_minute
saturated float32 utc_seconds
saturated float64 latitude
saturated float64 longitude
saturated float32 altitude
******************************************************************************/

#undef gps_status
#undef order
#undef remain_buffer
#undef utc_year
#undef utc_month
#undef utc_day
#undef utc_hour
#undef utc_minute
#undef utc_seconds
#undef latitude
#undef longitude
#undef altitude

namespace com
{
namespace xacti
{

template <int _tmpl>
struct UAVCAN_EXPORT GnssStatus_
{
    typedef const GnssStatus_<_tmpl>& ParameterType;
    typedef GnssStatus_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
    };

    struct FieldTypes
    {
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > gps_status;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > order;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > remain_buffer;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > utc_year;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > utc_month;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > utc_day;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > utc_hour;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > utc_minute;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > utc_seconds;
        typedef ::uavcan::FloatSpec< 64, ::uavcan::CastModeSaturate > latitude;
        typedef ::uavcan::FloatSpec< 64, ::uavcan::CastModeSaturate > longitude;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > altitude;
    };

    enum
    {
        MinBitLen
            = FieldTypes::gps_status::MinBitLen
            + FieldTypes::order::MinBitLen
            + FieldTypes::remain_buffer::MinBitLen
            + FieldTypes::utc_year::MinBitLen
            + FieldTypes::utc_month::MinBitLen
            + FieldTypes::utc_day::MinBitLen
            + FieldTypes::utc_hour::MinBitLen
            + FieldTypes::utc_minute::MinBitLen
            + FieldTypes::utc_seconds::MinBitLen
            + FieldTypes::latitude::MinBitLen
            + FieldTypes::longitude::MinBitLen
            + FieldTypes::altitude::MinBitLen
    };

    enum
    {
        MaxBitLen
            = FieldTypes::gps_status::MaxBitLen
            + FieldTypes::order::MaxBitLen
            + FieldTypes::remain_buffer::MaxBitLen
            + FieldTypes::utc_year::MaxBitLen
            + FieldTypes::utc_month::MaxBitLen
            + FieldTypes::utc_day::MaxBitLen
            + FieldTypes::utc_hour::MaxBitLen
            + FieldTypes::utc_minute::MaxBitLen
            + FieldTypes::utc_seconds::MaxBitLen
            + FieldTypes::latitude::MaxBitLen
            + FieldTypes::longitude::MaxBitLen
            + FieldTypes::altitude::MaxBitLen
    };

    // Constants

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::gps_status >::Type gps_status;
    typename ::uavcan::StorageType< typename FieldTypes::order >::Type order;
    typename ::uavcan::StorageType< typename FieldTypes::remain_buffer >::Type remain_buffer;
    typename ::uavcan::StorageType< typename FieldTypes::utc_year >::Type utc_year;
    typename ::uavcan::StorageType< typename FieldTypes::utc_month >::Type utc_month;
    typename ::uavcan::StorageType< typename FieldTypes::utc_day >::Type utc_day;
    typename ::uavcan::StorageType< typename FieldTypes::utc_hour >::Type utc_hour;
    typename ::uavcan::StorageType< typename FieldTypes::utc_minute >::Type utc_minute;
    typename ::uavcan::StorageType< typename FieldTypes::utc_seconds >::Type utc_seconds;
    typename ::uavcan::StorageType< typename FieldTypes::latitude >::Type latitude;
    typename ::uavcan::StorageType< typename FieldTypes::longitude >::Type longitude;
    typename ::uavcan::StorageType< typename FieldTypes::altitude >::Type altitude;

    GnssStatus_()
        : gps_status()
        , order()
        , remain_buffer()
        , utc_year()
        , utc_month()
        , utc_day()
        , utc_hour()
        , utc_minute()
        , utc_seconds()
        , latitude()
        , longitude()
        , altitude()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<264 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    enum { DefaultDataTypeID = 20305 };

    static const char* getDataTypeFullName()
    {
        return "com.xacti.GnssStatus";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool GnssStatus_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        gps_status == rhs.gps_status &&
        order == rhs.order &&
        remain_buffer == rhs.remain_buffer &&
        utc_year == rhs.utc_year &&
        utc_month == rhs.utc_month &&
        utc_day == rhs.utc_day &&
        utc_hour == rhs.utc_hour &&
        utc_minute == rhs.utc_minute &&
        utc_seconds == rhs.utc_seconds &&
        latitude == rhs.latitude &&
        longitude == rhs.longitude &&
        altitude == rhs.altitude;
}

template <int _tmpl>
bool GnssStatus_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(gps_status, rhs.gps_status) &&
        ::uavcan::areClose(order, rhs.order) &&
        ::uavcan::areClose(remain_buffer, rhs.remain_buffer) &&
        ::uavcan::areClose(utc_year, rhs.utc_year) &&
        ::uavcan::areClose(utc_month, rhs.utc_month) &&
        ::uavcan::areClose(utc_day, rhs.utc_day) &&
        ::uavcan::areClose(utc_hour, rhs.utc_hour) &&
        ::uavcan::areClose(utc_minute, rhs.utc_minute) &&
        ::uavcan::areClose(utc_seconds, rhs.utc_seconds) &&
        ::uavcan::areClose(latitude, rhs.latitude) &&
        ::uavcan::areClose(longitude, rhs.longitude) &&
        ::uavcan::areClose(altitude, rhs.altitude);
}

template <int _tmpl>
int GnssStatus_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::gps_status::encode(self.gps_status, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::order::encode(self.order, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::remain_buffer::encode(self.remain_buffer, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_year::encode(self.utc_year, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_month::encode(self.utc_month, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_day::encode(self.utc_day, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_hour::encode(self.utc_hour, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_minute::encode(self.utc_minute, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_seconds::encode(self.utc_seconds, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::latitude::encode(self.latitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::longitude::encode(self.longitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::altitude::encode(self.altitude, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int GnssStatus_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::gps_status::decode(self.gps_status, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::order::decode(self.order, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::remain_buffer::decode(self.remain_buffer, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_year::decode(self.utc_year, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_month::decode(self.utc_month, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_day::decode(self.utc_day, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_hour::decode(self.utc_hour, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_minute::decode(self.utc_minute, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::utc_seconds::decode(self.utc_seconds, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::latitude::decode(self.latitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::longitude::decode(self.longitude, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::altitude::decode(self.altitude, codec,  tao_mode);
    return res;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature GnssStatus_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0x3413AC5D3E1DCBE3ULL);

    FieldTypes::gps_status::extendDataTypeSignature(signature);
    FieldTypes::order::extendDataTypeSignature(signature);
    FieldTypes::remain_buffer::extendDataTypeSignature(signature);
    FieldTypes::utc_year::extendDataTypeSignature(signature);
    FieldTypes::utc_month::extendDataTypeSignature(signature);
    FieldTypes::utc_day::extendDataTypeSignature(signature);
    FieldTypes::utc_hour::extendDataTypeSignature(signature);
    FieldTypes::utc_minute::extendDataTypeSignature(signature);
    FieldTypes::utc_seconds::extendDataTypeSignature(signature);
    FieldTypes::latitude::extendDataTypeSignature(signature);
    FieldTypes::longitude::extendDataTypeSignature(signature);
    FieldTypes::altitude::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

/*
 * Final typedef
 */
typedef GnssStatus_<0> GnssStatus;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::com::xacti::GnssStatus > _uavcan_gdtr_registrator_GnssStatus;

}

} // Namespace xacti
} // Namespace com

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::com::xacti::GnssStatus >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::com::xacti::GnssStatus::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::com::xacti::GnssStatus >::stream(Stream& s, ::com::xacti::GnssStatus::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "gps_status: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::gps_status >::stream(s, obj.gps_status, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "order: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::order >::stream(s, obj.order, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "remain_buffer: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::remain_buffer >::stream(s, obj.remain_buffer, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "utc_year: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::utc_year >::stream(s, obj.utc_year, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "utc_month: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::utc_month >::stream(s, obj.utc_month, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "utc_day: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::utc_day >::stream(s, obj.utc_day, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "utc_hour: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::utc_hour >::stream(s, obj.utc_hour, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "utc_minute: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::utc_minute >::stream(s, obj.utc_minute, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "utc_seconds: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::utc_seconds >::stream(s, obj.utc_seconds, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "latitude: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::latitude >::stream(s, obj.latitude, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "longitude: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::longitude >::stream(s, obj.longitude, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "altitude: ";
    YamlStreamer< ::com::xacti::GnssStatus::FieldTypes::altitude >::stream(s, obj.altitude, level + 1);
}

}

namespace com
{
namespace xacti
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::com::xacti::GnssStatus::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::com::xacti::GnssStatus >::stream(s, obj, 0);
    return s;
}

} // Namespace xacti
} // Namespace com

#endif // COM_XACTI_GNSSSTATUS_HPP_INCLUDED